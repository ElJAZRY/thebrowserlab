import * as THREE from 'three';
import { AnnotationClass } from '../../types/annotation';

export interface SyntheticDataImage {
  id: string;
  dataUrl: string;
  width: number;
  height: number;
  cameraPosition: THREE.Vector3;
  cameraRotation: THREE.Euler;
  annotations: SyntheticDataAnnotation[];
}

export interface SyntheticDataAnnotation {
  objectId: string;
  classId: string;
  className: string;
  bbox: [number, number, number, number]; // [x, y, width, height]
  segmentation: number[][]; // Array of polygons
  area: number;
  iscrowd: number;
  keypoints?: number[]; // [x1, y1, v1, x2, y2, v2, ...] where v is visibility
  num_keypoints?: number;
}

export function exportAsCOCO(
  images: SyntheticDataImage[],
  classes: AnnotationClass[]
): any {
  // Create COCO format structure
  const cocoData = {
    info: {
      description: 'Synthetic data generated by Browser Lab',
      url: '',
      version: '1.0',
      year: new Date().getFullYear(),
      contributor: 'Browser Lab',
      date_created: new Date().toISOString()
    },
    licenses: [
      {
        id: 1,
        name: 'Attribution-NonCommercial-ShareAlike License',
        url: 'http://creativecommons.org/licenses/by-nc-sa/2.0/'
      }
    ],
    images: [],
    annotations: [],
    categories: []
  };
  
  // Add categories
  classes.forEach((cls, index) => {
    cocoData.categories.push({
      id: index + 1,
      name: cls.name,
      supercategory: 'object'
    });
  });
  
  // Add images and annotations
  images.forEach((image, imageIndex) => {
    // Add image
    cocoData.images.push({
      id: imageIndex + 1,
      file_name: `${image.id}.png`,
      width: image.width,
      height: image.height,
      date_captured: new Date().toISOString()
    });
    
    // Add annotations for this image
    image.annotations.forEach((anno, annoIndex) => {
      const categoryId = cocoData.categories.findIndex(c => c.name === anno.className) + 1;
      
      cocoData.annotations.push({
        id: imageIndex * 1000 + annoIndex + 1,
        image_id: imageIndex + 1,
        category_id: categoryId,
        bbox: anno.bbox,
        segmentation: anno.segmentation,
        area: anno.area,
        iscrowd: anno.iscrowd,
        keypoints: anno.keypoints || [],
        num_keypoints: anno.num_keypoints || 0
      });
    });
  });
  
  return cocoData;
}

export function exportAsPascalVOC(
  images: SyntheticDataImage[],
  classes: AnnotationClass[]
): any {
  // For simplicity, we'll return a JSON representation of Pascal VOC
  // In a real implementation, this would generate XML files
  return {
    format: 'PASCAL_VOC',
    data: images.map(image => ({
      filename: `${image.id}.png`,
      width: image.width,
      height: image.height,
      objects: image.annotations.map(anno => ({
        name: anno.className,
        pose: 'Unspecified',
        truncated: 0,
        difficult: 0,
        bndbox: {
          xmin: Math.round(anno.bbox[0]),
          ymin: Math.round(anno.bbox[1]),
          xmax: Math.round(anno.bbox[0] + anno.bbox[2]),
          ymax: Math.round(anno.bbox[1] + anno.bbox[3])
        }
      }))
    }))
  };
}

export function exportAsYOLO(
  images: SyntheticDataImage[],
  classes: AnnotationClass[]
): any {
  // For simplicity, we'll return a JSON representation of YOLO format
  // In a real implementation, this would generate .txt files
  const classMap = {};
  classes.forEach((cls, index) => {
    classMap[cls.name] = index;
  });
  
  return {
    format: 'YOLO',
    classes: classes.map(cls => cls.name),
    data: images.map(image => ({
      image: `${image.id}.png`,
      annotations: image.annotations.map(anno => {
        const classId = classMap[anno.className];
        const x = (anno.bbox[0] + anno.bbox[2] / 2) / image.width;
        const y = (anno.bbox[1] + anno.bbox[3] / 2) / image.height;
        const w = anno.bbox[2] / image.width;
        const h = anno.bbox[3] / image.height;
        return `${classId} ${x.toFixed(6)} ${y.toFixed(6)} ${w.toFixed(6)} ${h.toFixed(6)}`;
      })
    }))
  };
}